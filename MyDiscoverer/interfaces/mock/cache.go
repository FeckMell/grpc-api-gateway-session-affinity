// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"mydiscoverer/interfaces"
	"sync"
)

// Ensure, that CacheMock does implement interfaces.Cache.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Cache[any] = &CacheMock[any]{}

// CacheMock is a mock implementation of interfaces.Cache.
//
//	func TestSomethingThatUsesCache(t *testing.T) {
//
//		// make and configure a mocked interfaces.Cache
//		mockedCache := &CacheMock{
//			DeleteValueFunc: func(ctx context.Context, key string) error {
//				panic("mock out the DeleteValue method")
//			},
//			ListAllValuesFunc: func(ctx context.Context) ([]T, error) {
//				panic("mock out the ListAllValues method")
//			},
//			WriteValueFunc: func(ctx context.Context, key string, item T, ttlMs int) error {
//				panic("mock out the WriteValue method")
//			},
//		}
//
//		// use mockedCache in code that requires interfaces.Cache
//		// and then make assertions.
//
//	}
type CacheMock[T any] struct {
	// DeleteValueFunc mocks the DeleteValue method.
	DeleteValueFunc func(ctx context.Context, key string) error

	// ListAllValuesFunc mocks the ListAllValues method.
	ListAllValuesFunc func(ctx context.Context) ([]T, error)

	// WriteValueFunc mocks the WriteValue method.
	WriteValueFunc func(ctx context.Context, key string, item T, ttlMs int) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteValue holds details about calls to the DeleteValue method.
		DeleteValue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ListAllValues holds details about calls to the ListAllValues method.
		ListAllValues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// WriteValue holds details about calls to the WriteValue method.
		WriteValue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Item is the item argument value.
			Item T
			// TtlMs is the ttlMs argument value.
			TtlMs int
		}
	}
	lockDeleteValue   sync.RWMutex
	lockListAllValues sync.RWMutex
	lockWriteValue    sync.RWMutex
}

// DeleteValue calls DeleteValueFunc.
func (mock *CacheMock[T]) DeleteValue(ctx context.Context, key string) error {
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDeleteValue.Lock()
	mock.calls.DeleteValue = append(mock.calls.DeleteValue, callInfo)
	mock.lockDeleteValue.Unlock()
	if mock.DeleteValueFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteValueFunc(ctx, key)
}

// DeleteValueCalls gets all the calls that were made to DeleteValue.
// Check the length with:
//
//	len(mockedCache.DeleteValueCalls())
func (mock *CacheMock[T]) DeleteValueCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDeleteValue.RLock()
	calls = mock.calls.DeleteValue
	mock.lockDeleteValue.RUnlock()
	return calls
}

// ListAllValues calls ListAllValuesFunc.
func (mock *CacheMock[T]) ListAllValues(ctx context.Context) ([]T, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListAllValues.Lock()
	mock.calls.ListAllValues = append(mock.calls.ListAllValues, callInfo)
	mock.lockListAllValues.Unlock()
	if mock.ListAllValuesFunc == nil {
		var (
			vsOut  []T
			errOut error
		)
		return vsOut, errOut
	}
	return mock.ListAllValuesFunc(ctx)
}

// ListAllValuesCalls gets all the calls that were made to ListAllValues.
// Check the length with:
//
//	len(mockedCache.ListAllValuesCalls())
func (mock *CacheMock[T]) ListAllValuesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListAllValues.RLock()
	calls = mock.calls.ListAllValues
	mock.lockListAllValues.RUnlock()
	return calls
}

// WriteValue calls WriteValueFunc.
func (mock *CacheMock[T]) WriteValue(ctx context.Context, key string, item T, ttlMs int) error {
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Item  T
		TtlMs int
	}{
		Ctx:   ctx,
		Key:   key,
		Item:  item,
		TtlMs: ttlMs,
	}
	mock.lockWriteValue.Lock()
	mock.calls.WriteValue = append(mock.calls.WriteValue, callInfo)
	mock.lockWriteValue.Unlock()
	if mock.WriteValueFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.WriteValueFunc(ctx, key, item, ttlMs)
}

// WriteValueCalls gets all the calls that were made to WriteValue.
// Check the length with:
//
//	len(mockedCache.WriteValueCalls())
func (mock *CacheMock[T]) WriteValueCalls() []struct {
	Ctx   context.Context
	Key   string
	Item  T
	TtlMs int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Item  T
		TtlMs int
	}
	mock.lockWriteValue.RLock()
	calls = mock.calls.WriteValue
	mock.lockWriteValue.RUnlock()
	return calls
}
